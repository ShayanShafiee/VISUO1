# processing/file_handler.py


"""File discovery and grouping helpers.

Parses TIFF filenames to extract metadata (date, animal id, time point, image
type) and constructs nested dictionaries for fast access by animal/time. The
regex-based parser is resilient to additional dashes or tokens between
expected segments by using non-greedy matches.

Primary utilities:
 - parse_filename(path): returns structured components or None if pattern fails
 - group_files(root_dir): walks directory tree and groups WF/FL pairs
 - get_random_image_pair(grouped): selects a random valid pair for preview

Returned data shape from group_files:
        {
            "DATE_ANIMALID": {
                    "TIME": {"WF": wf_path, "FL": fl_path},
                    ...
            },
            ...
        }

All time strings are zeroâ€‘padded for consistent sorting (e.g., "30" -> "0030").
"""

import os
import re
from collections import defaultdict
from typing import Dict, List, Optional, Tuple
import random

# Regex to capture the key components of the filename.
# It captures: Date, Animal ID (including group info), Time, and Type (WF/FL).
FILENAME_PATTERN = re.compile(
    r"(\d{8})-"  # 1: Date (e.g., 20250716)
    r".*?-"      # Non-greedy match for other info
    r"([Gg]\d{1,3}-.*?-[Aa]\d{1,3})-"  # 2: Animal ID (e.g., G11-F-12Gy-SHOV-A01)
    r"[Tt](\d{3,4})min-"  # 3: Time point (e.g., 030 or 0000)
    r"(FL|WF)_"  # 4: Image Type (FL or WF)
)

def parse_filename(filepath: str) -> Optional[Dict[str, str]]:
    """
    Uses regex to extract metadata from a filename.

    Args:
        filepath (str): The full path to the TIFF file.

    Returns:
        A dictionary with 'date', 'animal_id', 'time', 'type', and 'path'
        if the filename matches the pattern, otherwise None.
    """
    filename = os.path.basename(filepath)
    match = FILENAME_PATTERN.search(filename)
    if match:
        return {
            "date": match.group(1),
            "animal_id": match.group(2),
            "time": match.group(3).zfill(4),  # Pad with zeros for sorting (e.g., 30 -> 0030)
            "type": match.group(4),
            "path": filepath,
        }
    return None

def group_files(main_directory: str) -> Dict[str, Dict[str, Dict[str, str]]]:
    """
    Scans a directory recursively, parses all TIFF filenames, and groups them
    by a unique animal identifier (Date + Animal ID).

    Args:
        main_directory (str): The root directory to start the scan from.

    Returns:
        A nested dictionary structured as:
        {
            "unique_animal_key": {
                "time_point": {"WF": path, "FL": path},
                ...
            },
            ...
        }
        Example key: "20250716_G11-F-12Gy-SHOV-A01"
    """
    grouped_data = defaultdict(lambda: defaultdict(dict))
    
    for root, _, files in os.walk(main_directory):
        for file in files:
            if file.lower().endswith((".tif", ".tiff")):
                filepath = os.path.join(root, file)
                parsed_info = parse_filename(filepath)
                
                if parsed_info:
                    unique_key = f"{parsed_info['date']}_{parsed_info['animal_id']}"
                    time_point = parsed_info['time']
                    image_type = parsed_info['type']
                    
                    grouped_data[unique_key][time_point][image_type] = parsed_info['path']
                    
    # Convert defaultdicts to regular dicts for the final output
    return {key: dict(value) for key, value in grouped_data.items()}

def get_random_image_pair(grouped_data: Dict) -> Optional[Tuple[str, str]]:
    """
    Selects a random, valid WF/FL pair from the grouped data.

    Args:
        grouped_data: The dictionary generated by group_files.

    Returns:
        A tuple containing (path_to_wf, path_to_fl), or None if no valid pair is found.
    """
    # Create a list of all available pairs
    valid_pairs = []
    for animal_data in grouped_data.values():
        for time_data in animal_data.values():
            if "WF" in time_data and "FL" in time_data:
                valid_pairs.append((time_data["WF"], time_data["FL"]))
    
    if not valid_pairs:
        return None
        
    return random.choice(valid_pairs)